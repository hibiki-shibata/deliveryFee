/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package feeee

import io.ktor.application.*
import io.ktor.features.ContentNegotiation
import io.ktor.http.ContentType
import io.ktor.request.receive
import io.ktor.response.respond
import io.ktor.routing.post
import io.ktor.routing.routing
import io.ktor.serialization.json
import io.ktor.server.engine.embeddedServer
import io.ktor.server.netty.Netty
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.time.ZoneOffset
import io.ktor.http.HttpStatusCode
import java.time.DayOfWeek
import java.time.OffsetDateTime
import kotlin.math.ceil

import feeee.Deliveryfee

@Serializable
data class DeliveryRequest(
    val cart_value: Int, // cent
    val delivery_distance: Int, //meter
    val number_of_items: Int,
    val time: String // UTC
)


@Serializable
data class DeliveryResponse(
    val delivery_fee: Int
)


fun main() {
    embeddedServer(Netty, port = 8080) {
        install(ContentNegotiation) {
            json(Json { ignoreUnknownKeys = true })
        }

        routing {
            post("/delivery-fee") {
                try {
                    val request = call.receive<DeliveryRequest>()
                    if(!jsonVerificatoin(request)){
                        call.respond(HttpStatusCode.BadRequest, "Invalid request")
                    }
                    val feecalculation = Deliveryfee();
                    val deliveryFee = feecalculation.calculateDeliveryFee(request);
                    call.respond(DeliveryResponse(deliveryFee));

                } catch (e: Exception) {
                    call.respond(HttpStatusCode.InternalServerError, "Internal Server Error\nDetails: ${e}")
                    e.printStackTrace()
                    // println("something went wrong!")
                }
            }
        }
    }.start(wait = true)
}


// request validation
fun jsonVerificatoin(request: DeliveryRequest): Boolean {
    return request.cart_value >= 0 &&
            request.delivery_distance >= 0 &&
            request.number_of_items >= 0 &&
            isValidTime(request.time)
}


fun isValidTime(time: String): Boolean {
    return try {
        OffsetDateTime.parse(time)
        true
    } catch (e: Exception) {
        false
    }
}