/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package indexfile

import io.ktor.application.*
import io.ktor.features.ContentNegotiation
import io.ktor.http.ContentType
import io.ktor.request.receive
import io.ktor.response.respond
import io.ktor.routing.post
import io.ktor.routing.routing
import io.ktor.serialization.json
import io.ktor.server.engine.embeddedServer
import io.ktor.server.netty.Netty
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.time.ZoneOffset
import io.ktor.http.HttpStatusCode
import java.time.DayOfWeek
import java.time.OffsetDateTime
import kotlin.math.ceil

import CalculateTotalDeliveryFee.Deliveryfee

@Serializable
data class FeeCalcRequest(
    val cart_value: Int, // cent
    val delivery_distance: Int, //meter
    val number_of_items: Int,
    val time: String // UTC
)


@Serializable
data class FeecCalcResponse(
    val delivery_fee: Int
)


fun main() {
    embeddedServer(Netty, port = 8080) {
        install(ContentNegotiation) {
            json(Json { ignoreUnknownKeys = true })
        }

        routing {
            post("/delivery-fee") {
                try {
                    val request = call.receive<FeeCalcRequest>()
                    if(!jsonVerificatoin(request)){
                        call.respond(HttpStatusCode.BadRequest, "Invalid Json request")
                    }
                    val feecalculation = Deliveryfee();
                    val FinalFee = feecalculation.SumDeliveryFee(request);
                    call.respond(FeecCalcResponse(FinalFee));

                } catch (e: Exception) {
                    call.respond(HttpStatusCode.InternalServerError, "Internal Server Error\nDetails: ${e}")
                    e.printStackTrace()
                    // println("something went wrong!")
                }
            }
        }
    }.start(wait = true)
}


// request validation
fun jsonVerificatoin(request: FeeCalcRequest): Boolean {
    return  request.cart_value >= 0 &&
            request.delivery_distance >= 0 &&
            request.number_of_items >= 0 &&
            isValidTime(request.time)
}


fun isValidTime(time: String): Boolean {
    return try {
                OffsetDateTime.parse(time)
                true
                } catch (e: Exception) {
                false
            }
}

// API testing
// Use Class
//Make the name more readable
// Library versino
// Scalability / How to change when you have to make change as Happyhour changed?
// Library versions
// should make routing scalability